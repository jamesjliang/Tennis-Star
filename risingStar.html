<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="James Liang">
<meta name="dcterms.date" content="2025-02-10">

<title>The Rising Tennis Star</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="tennis_star_refined_files/libs/clipboard/clipboard.min.js"></script>
<script src="tennis_star_refined_files/libs/quarto-html/quarto.js"></script>
<script src="tennis_star_refined_files/libs/quarto-html/popper.min.js"></script>
<script src="tennis_star_refined_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="tennis_star_refined_files/libs/quarto-html/anchor.min.js"></script>
<link href="tennis_star_refined_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="tennis_star_refined_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="tennis_star_refined_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="tennis_star_refined_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="tennis_star_refined_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="formatting.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Rising Tennis Star</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>James Liang </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- Guide to using quarto at https://quarto.org/docs/get-started/hello/rstudio.html -->
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>Tennis has long been defined by the dominance of three extraordinary players—Novak Djokovic, Rafael Nadal, and Roger Federer. Their achievements, spanning almost two uncontested decades, have set an unparalleled benchmark in the sport. Their rivalry, marked by intense matches and moments of brilliance, has captivated fans around the world, pushing the boundaries of what was thought possible in tennis.</p>
<p>For me, growing up in the leafy suburbs of Melbourne, watching their plays at the Australian Open with my family became a warm, nostalgic tradition. Whether we gathered around that small TV in the living room, all squeezed together, or simply let the matches play softly in the background, it was always a moment that brought us closer, especially as we cheered on our favourite three players. However, with their gradual transition away from professional play, a new generation of rising stars is poised to reshape the competitive landscape.</p>
<p>This report aims to provide:</p>
<ul>
<li><p>A quantitative exploration of the Big 3’s dominance</p></li>
<li><p>A data-driven analysis of how the sport has evolved, and</p></li>
<li><p>A statistical approach to identifying the key attributes that define a tennis superstar.</p></li>
</ul>
<p>Leveraging analytical techniques—including visualisations, regressions, and principal component analysis (PCA) - this study uncovers patterns in performance metrics, player trajectories, and the factors influencing success at the highest level. This report offers insights into the shifting dynamics of professional tennis and highlights the emerging talents most likely to leave their mark on the sport.</p>
<div class="center">
<p><img src="images/big_3.webp" class="img-fluid" style="width:110.0%"></p>
</div>
</section>
<section id="preparing-the-data" class="level2">
<h2 class="anchored" data-anchor-id="preparing-the-data">Preparing the Data</h2>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<p>Data used for this report includes:</p>
<ul>
<li><a href="'https://github.com/JeffSackmann/tennis_atp'">Association of Tennis Professionals (ATP) Match Statistics</a> by Jeff Sackmann, containing raw match summaries from major ATP tournament from 1968 to 2024, including details such as match duration, match outcomes, and basic statistics such as Aces or Break Points Saved.</li>
</ul>
<div id="atp-data" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">##### 1. Association of Tennis Professionals (ATP) Match Statistics #####</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1968</span>, <span class="dv">2025</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>base_url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/JeffSackmann/tennis_atp/master/atp_matches_</span><span class="sc">{}</span><span class="st">.csv"</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Read and concatenate all CSV files</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>dfs <span class="op">=</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> base_url.<span class="bu">format</span>(year)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        dfs.append(df)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Successfully loaded: {year}")</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Failed to load </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine all dataframes</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>atp_match_stats <span class="op">=</span> pd.concat(dfs, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># atp_match_stats.to_csv("data/atp_1968-2024.csv", index=False)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>atp_match_stats <span class="op">=</span> pd.read_csv(<span class="st">'data/atp_1968-2024.csv'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><a href="https://github.com/JeffSackmann/tennis_atp/blob/master/atp_players.csv">ATP Player Information</a> by Jeff Sackmann, containing the personal attributes of ATP players, including details such as player birth year, country of origin, and other personal attributes.</li>
</ul>
<div id="7421f00c" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### 2. ATP Player Information #####</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>base_url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_players.csv"</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>player_info <span class="op">=</span> pd.read_csv(base_url)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><a href="https://github.com/JeffSackmann/tennis_atp/blob/master/atp_rankings_00s.csv">ATP Rankings</a> by Jeff Sackmann, containing the weekly rankings of all ATP players.</li>
</ul>
<div id="atp-rankings" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### 3. ATP Rankings #####</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>base_url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_rankings_</span><span class="sc">{}</span><span class="st">s.csv"</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'00'</span>, <span class="st">'10'</span>, <span class="st">'20'</span>, <span class="st">'90'</span>, <span class="st">'80'</span>, <span class="st">'70'</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Read and concatenate all CSV files</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dfs <span class="op">=</span> []</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> base_url.<span class="bu">format</span>(year)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        df <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        dfs.append(df)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"Successfully loaded: {year}")</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Failed to load </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Append current rankings up to 2024</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>current_seed_url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_rankings_current.csv"</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(current_seed_url)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>dfs.append(df)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine all dataframes</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>player_seed <span class="op">=</span> pd.concat(dfs, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># player_seed = pd.read_csv('data/all_ranking_data.csv')</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><a href="https://doi.org/10.1093/jrsssa/qnae027">ATP Advanced Match Statistics (Manual Match Labels)</a> by Nirodha Epasinghege Dona, Paramjit S. Gill, and Tim B. Swartz, which aggregates manually labeled shot-by-shot data from Sackmann’s open-source Match Charting Project. The primary dataset used in this report is sourced from Journal of the Royal Statistical Society Series A: Statistics in Society, Volume 188, Issue 1, January 2025, Pages 188–204.</li>
</ul>
<div id="atp-advanced-stats" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### 4. ATP Advanced Match Statistics #####</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>advanced_match_stats <span class="op">=</span> pd.read_csv(<span class="st">'data/Supp_1_men_data.csv'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><a href="https://www.tennisabstract.com/cgi-bin/leaders.cgi">Tennis Abstract Metrics</a> by Jeff Sackmann, containing the Top 100 player related statistics, scraped from the site.</li>
</ul>
<div id="tennis-abstract-metrics" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">##### 4. ATP Advanced Match Statistics #####</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info <span class="op">=</span> pd.read_csv(<span class="st">"data/atp_100_advanced_player_info.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="preprocess-data" class="level3">
<h3 class="anchored" data-anchor-id="preprocess-data">Preprocess Data</h3>
<p>The datasets used in this report are relatively well-maintained and structured, making them suitable for analysis with minimal preprocessing. However, before proceeding, a simple data inspection was conducted to ensure consistency, completeness, and accuracy.</p>
<ol type="1">
<li>Data Integrity Checks Before making any transformations, each dataset was reviewed for missing values, inconsistencies, and potential errors. This included:</li>
</ol>
<ul>
<li>Uniqueness Checks</li>
<li>Identifying missing or null values</li>
<li>Data type consistency (e.g.&nbsp;Change percentage-based statistics from strings to numerical values).</li>
</ul>
<ol start="2" type="1">
<li>Handling Missing Data</li>
</ol>
<ul>
<li>One notable issue was found in the ATP Player Rankings dataset, where weekly ranking updates were not always recorded, leaving intermittent gaps in the timeline. Since player rankings are updated every Monday, missing data could result in misleading trends when analyzing ranking progression.</li>
</ul>
<div id="1a0bbd4d" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load dataset</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> player_seed.copy()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"ranking_date"</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">"ranking_date"</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate expected weekly range (ATP rankings update every Monday)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>full_date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span>df[<span class="st">"ranking_date"</span>].<span class="bu">min</span>(), end<span class="op">=</span>df[<span class="st">"ranking_date"</span>].<span class="bu">max</span>(), freq<span class="op">=</span><span class="st">"W-MON"</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Get missing weeks</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>missing_weeks <span class="op">=</span> full_date_range.difference(df[<span class="st">"ranking_date"</span>].unique())</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot rankings and missing weeks</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>plt.scatter(df[<span class="st">"ranking_date"</span>], [<span class="dv">1</span>] <span class="op">*</span> <span class="bu">len</span>(df), label<span class="op">=</span><span class="st">"Available Weeks"</span>, color<span class="op">=</span><span class="st">"blue"</span>, marker<span class="op">=</span><span class="st">"o"</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>plt.scatter(missing_weeks, [<span class="dv">1</span>] <span class="op">*</span> <span class="bu">len</span>(missing_weeks), label<span class="op">=</span><span class="st">"Missing Weeks"</span>, color<span class="op">=</span><span class="st">"red"</span>, marker<span class="op">=</span><span class="st">"x"</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Date"</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Ranking Weeks"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"ATP Ranking Weeks: Missing Weeks Visualization"</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> missing_weeks.empty:</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"✅ No missing weeks. All rankings are accounted for."</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">❌ Missing </span><span class="sc">{</span><span class="bu">len</span>(missing_weeks)<span class="sc">}</span><span class="ss"> of </span><span class="sc">{</span><span class="bu">len</span>(full_date_range)<span class="sc">}</span><span class="ss"> weeks</span><span class="ch">\n</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-7-output-1.png" width="601" height="474" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
❌ Missing 422 of 2680 weeks
</code></pre>
</div>
</div>
<p>To address this, forward filling was applied to interpolate missing dates, by assuming that a player’s ranking remained the same until the next recorded update. At the same time, it is noteworthy to mention that between 2020-03-23 and 2020-08-23, due to COVID lockdowns, many tournaments were unable to proceed, and hence ATP ranking were frozen during the period.</p>
<div id="ffb8cb97" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load dataset</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> player_seed.copy()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">"ranking_date"</span>] <span class="op">=</span> pd.to_datetime(final_df[<span class="st">"ranking_date"</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort by player and date</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> final_df.sort_values(by<span class="op">=</span>[<span class="st">"player"</span>, <span class="st">"ranking_date"</span>]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full weekly date range</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>full_date_range <span class="op">=</span> pd.date_range(start<span class="op">=</span>final_df[<span class="st">"ranking_date"</span>].<span class="bu">min</span>(), end<span class="op">=</span>final_df[<span class="st">"ranking_date"</span>].<span class="bu">max</span>(), freq<span class="op">=</span><span class="st">"W-MON"</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dataframe with all player-week combinations</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>players <span class="op">=</span> final_df[<span class="st">"player"</span>].unique()</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>date_expanded <span class="op">=</span> pd.MultiIndex.from_product([players, full_date_range], names<span class="op">=</span>[<span class="st">"player"</span>, <span class="st">"ranking_date"</span>])</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>expanded_df <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>date_expanded).reset_index()</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge with original data</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> expanded_df.merge(final_df, on<span class="op">=</span>[<span class="st">"player"</span>, <span class="st">"ranking_date"</span>], how<span class="op">=</span><span class="st">"left"</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward-fill missing values (impute rank and points)</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">"rank"</span>] <span class="op">=</span> merged_df.groupby(<span class="st">"player"</span>)[<span class="st">"rank"</span>].ffill()</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">"points"</span>] <span class="op">=</span> merged_df.groupby(<span class="st">"player"</span>)[<span class="st">"points"</span>].ffill()</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove any rows where `rank` is still NaN (for players who didn't exist in the dataset yet)</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.dropna(subset<span class="op">=</span>[<span class="st">"rank"</span>])</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> merged_df.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Save or return final dataframe</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>merged_df.to_csv(<span class="st">"data/imputed_ranking_data.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"✅ Missing dates imputed successfully!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Missing dates imputed successfully!</code></pre>
</div>
</div>
<p>Another important issue to address, is that whilst ATP rankings are mostly complete from 1985 to the present, 1982 is missing, and rankings from 1973-1984 are especially intermittent - as raw data itself was not captured during the scraping process. Therefore, we will also filter the data from the year 2000, in addition to the forward filling that was applied.</p>
<div id="eb7ea237" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load dataset</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>imputed_rankings_raw <span class="op">=</span> pd.read_csv(<span class="st">"data/imputed_ranking_data.csv"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>imputed_rankings_raw[<span class="st">"ranking_date"</span>] <span class="op">=</span> pd.to_datetime(imputed_rankings_raw[<span class="st">"ranking_date"</span>])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove the frozen ranking period</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>imputed_rankings_raw <span class="op">=</span> imputed_rankings_raw[</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>((imputed_rankings_raw[<span class="st">"ranking_date"</span>] <span class="op">&gt;=</span> <span class="st">"2020-03-23"</span>) <span class="op">&amp;</span> (imputed_rankings_raw[<span class="st">"ranking_date"</span>] <span class="op">&lt;=</span> <span class="st">"2020-08-23"</span>))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter for years between 2000 and 2024</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>imputed_rankings <span class="op">=</span> imputed_rankings_raw[(imputed_rankings_raw[<span class="st">"ranking_date"</span>].dt.year <span class="op">&gt;=</span> <span class="dv">2000</span>) <span class="op">&amp;</span> (imputed_rankings_raw[<span class="st">"ranking_date"</span>].dt.year <span class="op">&lt;=</span> <span class="dv">2024</span>)]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">#####</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Rank 1 Players and The Number of Weeks at Rank 1</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>rank_1_df <span class="op">=</span> imputed_rankings[imputed_rankings[<span class="st">"rank"</span>] <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>rank_1_count <span class="op">=</span> rank_1_df.groupby(<span class="st">"player"</span>).size().reset_index(name<span class="op">=</span><span class="st">"Weeks at #1"</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>rank_1_count <span class="op">=</span> rank_1_count.sort_values(by<span class="op">=</span><span class="st">"Weeks at #1"</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> rank_1_count.merge(player_info, left_on<span class="op">=</span><span class="st">"player"</span>, right_on<span class="op">=</span><span class="st">"player_id"</span>, how<span class="op">=</span><span class="st">"left"</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co"># merged_df[['player_id', 'name_first', 'name_last', 'Weeks at #1']].head(6)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>After imputation, we can verify the accuracy of the dataset by examining the top ATP rankings of leading players, particularly Djokovic, Federer, and Nadal. It’s important to note that the forward-filled dataset has been filtered to include only players active on tour from the 2000s onward.</p>
<section id="atp-official-site-stats-vs.-forward-filled-data" class="level4">
<h4 class="anchored" data-anchor-id="atp-official-site-stats-vs.-forward-filled-data">ATP Official Site Stats Vs. Forward Filled Data</h4>
<div style="display: flex; justify-content: center; gap: 20px;">
<p><img src="images/atp_rankings_web.png" width="30%"> <img src="images/atp_rankings_manual.png" width="60%"></p>
</div>
<p><a href="https://www.atptour.com/en/rankings/former-no-1s">Link to ATP Historical Rank 1</a></p>
</section>
</section>
</section>
<section id="analysis" class="level2">
<h2 class="anchored" data-anchor-id="analysis">Analysis</h2>
<section id="a-dominating-trio" class="level3">
<h3 class="anchored" data-anchor-id="a-dominating-trio">A Dominating Trio</h3>
<section id="number-of-grand-slam-victories-by-player" class="level4">
<h4 class="anchored" data-anchor-id="number-of-grand-slam-victories-by-player">Number of Grand Slam Victories by Player</h4>
<div id="e0a4fbbf" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>final <span class="op">=</span> atp_match_stats[(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>            atp_match_stats[<span class="st">'tourney_level'</span>] <span class="op">==</span> <span class="st">'G'</span>) <span class="op">&amp;</span> (atp_match_stats[<span class="st">'round'</span>] <span class="op">==</span> <span class="st">'F'</span>)] <span class="op">\</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                .groupby(<span class="st">'winner_name'</span>)[<span class="st">'tourney_id'</span>] <span class="op">\</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                    .count().reset_index()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Rename and sort</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>final <span class="op">=</span> final.rename(columns<span class="op">=</span>{<span class="st">'tourney_id'</span>: <span class="st">'Grand Slam Wins'</span>}) <span class="op">\</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            .sort_values(by<span class="op">=</span><span class="st">'Grand Slam Wins'</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Set figure</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>sns.set_theme(style<span class="op">=</span><span class="st">"whitegrid"</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a color gradient with the most wins highlighted</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> sns.color_palette(<span class="st">"viridis"</span>, <span class="bu">len</span>(final))</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>highlight_color <span class="op">=</span> <span class="st">"purple"</span>  <span class="co"># Special color for the top player</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>bar_colors <span class="op">=</span> [highlight_color <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> colors[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(final))]</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> sns.barplot(x<span class="op">=</span><span class="st">"Grand Slam Wins"</span>, y<span class="op">=</span><span class="st">"winner_name"</span>, data<span class="op">=</span>final, palette<span class="op">=</span>bar_colors)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add annotations on bars</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, value <span class="kw">in</span> <span class="bu">enumerate</span>(final[<span class="st">"Grand Slam Wins"</span>]):</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    ax.text(value <span class="op">+</span> <span class="fl">0.5</span>, index, <span class="bu">str</span>(value), ha<span class="op">=</span><span class="st">"left"</span>, va<span class="op">=</span><span class="st">"center"</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>, color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Titles and Labels</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Number of Grand Slam Titles"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Player"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Top 10 Grand Slam Winners (1968-2024)"</span>, fontsize<span class="op">=</span><span class="dv">16</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>, pad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>sns.despine(left<span class="op">=</span><span class="va">True</span>, top<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-10-output-1.png" width="681" height="474" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The dominance of the Big Three—Roger Federer, Novak Djokovic, and Rafael Nadal—stands in stark contrast to even some of the sport’s greatest champions such as Pete Sampras, Andre Agassi, and Jimmy Connors, who each laid the foundation for modern tennis.</p>
<p>Their combined Grand Slam tally not only surpasses that of their predecessors but also accounts for a remarkable portion of total Grand Slam titles in the Open Era. Each of them has set records that were once thought untouchable—whether it be Federer’s elegant shot-making, Nadal’s clay-court dominance, or Djokovic’s unmatched consistency across all surfaces, these three are the only individuals in the history of tennis, to each amass over 20 Grand Slam Titles.</p>
<p>In contrast, current-generation players, such as Daniil Medvedev, Alexander Zverev, and Carlos Alcaraz, have fallen significantly short in terms of Grand Slam wins - which is hardly surprising, given that the Big Three have monopolized the Grand Slam victories over the past two decades, leaving little room for others to claim major titles.</p>
<div id="84a644ef" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> atp_match_stats.copy()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"tourney_date"</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">"tourney_date"</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter for Grand Slam finals from 1968 onwards</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    (df[<span class="st">'tourney_level'</span>] <span class="op">==</span> <span class="st">'G'</span>) <span class="op">&amp;</span> </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    (df[<span class="st">'round'</span>] <span class="op">==</span> <span class="st">'F'</span>) <span class="op">&amp;</span> </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    (df[<span class="st">'tourney_date'</span>].dt.year <span class="op">&gt;=</span> <span class="dv">2003</span>) <span class="op">&amp;</span> </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    (df[<span class="st">'tourney_date'</span>].dt.year <span class="op">&lt;=</span> <span class="dv">2022</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>].copy()</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Count Grand Slam wins per player</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.groupby(<span class="st">'winner_name'</span>)[<span class="st">'tourney_id'</span>].count().reset_index()</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Rename and sort</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.rename(columns<span class="op">=</span>{<span class="st">'tourney_id'</span>: <span class="st">'Grand Slam Wins'</span>}) <span class="op">\</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>       .sort_values(by<span class="op">=</span><span class="st">'Grand Slam Wins'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggregate total Grand Slam wins per player</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>grand_slam_totals <span class="op">=</span> df.groupby(<span class="st">"winner_name"</span>)[<span class="st">"Grand Slam Wins"</span>].<span class="bu">sum</span>()</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>big_3 <span class="op">=</span> [<span class="st">"Roger Federer"</span>, <span class="st">"Novak Djokovic"</span>, <span class="st">"Rafael Nadal"</span>]</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate proportions</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>big_3_wins <span class="op">=</span> grand_slam_totals[grand_slam_totals.index.isin(big_3)].<span class="bu">sum</span>()</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>total_wins <span class="op">=</span> grand_slam_totals.<span class="bu">sum</span>()</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>big_3_proportion <span class="op">=</span> big_3_wins <span class="op">/</span> total_wins</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>other_players_proportion <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> big_3_proportion</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Data for pie chart</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">"Federer, Nadal &amp; Djokovic"</span>, <span class="st">"Other Players"</span>]</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>sizes <span class="op">=</span> [big_3_proportion, other_players_proportion]</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">"gold"</span>, <span class="st">"lightgrey"</span>]</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Create pie chart</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>plt.pie(sizes, labels<span class="op">=</span>labels, autopct<span class="op">=</span><span class="st">"</span><span class="sc">%1.1f%%</span><span class="st">"</span>, colors<span class="op">=</span>colors, startangle<span class="op">=</span><span class="dv">140</span>, </span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        wedgeprops<span class="op">=</span>{<span class="st">"edgecolor"</span>: <span class="st">"black"</span>}, textprops<span class="op">=</span>{<span class="st">"fontsize"</span>: <span class="dv">12</span>})</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grand Slam Wins: Big 3 vs Other Players (2003-2022)"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>)</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Save plot</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"images/pie_chart_big_3.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">"tight"</span>)</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="img-float">
<p><img src="images/pie_chart_big_3.png" class="img-fluid" style="float: left; margin: 5px; width: 60%"></p>
</div>
<p>Since 2003, Roger Federer, Rafael Nadal, and Novak Djokovic have defined an era of dominance in men’s tennis, capturing the vast majority of Grand Slam titles during their Tour. Their achievements account for a remarkable share of total Grand Slam victories in the Open Era, setting a standard unmatched in the sport’s history. In fact, between 2003 and 2022, the three players alone, won 80% of all Grand Slam tournaments during those 2 decades.</p>
<p>Their overwhelming success, in comparison to all other players, underscores their sustained excellence and lasting impact on the game - an achievement that would be difficult to emulate for any player in future.</p>
</section>
<section id="the-rank-1-tennis-player-across-history" class="level4">
<h4 class="anchored" data-anchor-id="the-rank-1-tennis-player-across-history">The Rank 1 Tennis Player Across History</h4>
<p>Another key measure in tennis is the ATP Ranking. The ATP Ranking is based on a player’s performance over the past 52 weeks, using their best 19 tournament results. Points are awarded based on event prestige, with Grand Slams offering up to 2000 points and smaller tournaments awarding fewer. The ranking updates weekly, with points expiring after a year. Mandatory events include Grand Slams, ATP Masters 1000s, and the ATP Finals, where players can earn extra points. Missing key tournaments without a valid reason can result in penalties. This system rewards consistency and sustained success, influencing seeding, tournament entry, and career opportunities.</p>
<p>Being Rank 1 in the ATP Rankings means a player has accumulated the most ranking points over the past 52 weeks. Holding the No.&nbsp;1 ranking is a prestigious achievement, signifying dominance over the competition and granting advantages such as top seeding in tournaments.</p>
<p>To truly illustrate the degree of dominance held by the Big Three players, it is worth looking at the timeline of Rank 1 players, over the past 24 years.</p>
<div id="53dc0e27" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.colors <span class="im">as</span> mcolors</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine first and last names</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>player_info[<span class="st">'player_name'</span>] <span class="op">=</span> player_info[<span class="st">'name_first'</span>] <span class="op">+</span> <span class="st">" "</span> <span class="op">+</span> player_info[<span class="st">'name_last'</span>]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plot_df <span class="op">=</span> imputed_rankings[[<span class="st">"player"</span>, <span class="st">"ranking_date"</span>, <span class="st">"rank"</span>]]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort by player and ranking_date to ensure proper order</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plot_df <span class="op">=</span> plot_df.sort_values(by<span class="op">=</span>[<span class="st">"player"</span>, <span class="st">"ranking_date"</span>])</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge with player_info to get player names</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>player_rankings <span class="op">=</span> plot_df.merge(player_info[[<span class="st">'player_id'</span>, <span class="st">'player_name'</span>]], left_on<span class="op">=</span><span class="st">'player'</span>, right_on<span class="op">=</span><span class="st">'player_id'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># List of top players for plotting.</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>top_players <span class="op">=</span> rank_1_count[<span class="st">"player"</span>].tolist() </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the dataset for top players</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>top_players <span class="op">=</span> player_rankings[player_rankings[<span class="st">'player'</span>].isin(top_players)]</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co">############</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a pivot table with players as rows and years as columns</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>pivot_df <span class="op">=</span> top_players.pivot_table(index<span class="op">=</span><span class="st">'player_name'</span>, columns<span class="op">=</span><span class="st">'ranking_date'</span>, values<span class="op">=</span><span class="st">'rank'</span>, aggfunc<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>pivot_df <span class="op">=</span> pivot_df.where(pivot_df.notna(), <span class="va">None</span>) <span class="co"># Remove NAs</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>rank_one_df <span class="op">=</span> pivot_df.applymap(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="cf">if</span> x <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterate over each player to plot when they were ranked 1</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> player <span class="kw">in</span> rank_one_df.index:</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    rank_one_dates <span class="op">=</span> rank_one_df.columns[rank_one_df.loc[player].notna()]</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot a scatter plot of these dates for the player</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    plt.scatter(rank_one_dates, [player] <span class="op">*</span> <span class="bu">len</span>(rank_one_dates), label<span class="op">=</span>player, s<span class="op">=</span><span class="dv">100</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Ranking Date'</span>)</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Player'</span>)</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Timeline of Players Ranked #1 (2000 - Current)'</span>)</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-12-output-1.png" width="657" height="464" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>From 2004 to 2024, only four other players managed to reach the world No.&nbsp;1 spot outside of the Big Three. In stark contrast, in the four years prior to their reign (2000–2004), a total of seven different players claimed the top ranking, highlighting a much more volatile and competitive era. This shift in the rankings landscape marks a clear turning point in modern tennis, where Federer, Nadal, and Djokovic not only raised the bar but also established an era of unprecedented stability at the sport’s highest level.</p>
<p>Their sheer dominance underscores the significance of skill in tennis—sustained excellence at the top is no coincidence but rather a testament to their extraordinary level of play. It wasn’t just about winning titles; it was about consistently outclassing elite competition across different surfaces, conditions, and eras. The longevity of their success, spanning nearly two decades, speaks volumes about the gap they created between themselves and the rest of the field.</p>
<p>Yet, at the same time, since 2022, a noticeable shift has begun to take place. With Federer and Nadal’s retirement, and Djokovic gradually facing tougher competition from the next generation, the era of the Big Three appears to be winding down, with newer players such as Alcaraz and Sinner, taking on the title as Rank 1 in the past 2 years.</p>
</section>
</section>
<section id="the-changing-tennis-landscape" class="level3">
<h3 class="anchored" data-anchor-id="the-changing-tennis-landscape">The Changing Tennis Landscape</h3>
<section id="rallying-and-serving" class="level4">
<h4 class="anchored" data-anchor-id="rallying-and-serving">Rallying and Serving</h4>
<p>To understand how tennis has evolved over time, it is essential to examine both the changes in the style of play and the factors influencing these shifts. One noticeable change is the increasing length of rallies in modern tennis. While some sources, like <a href="https://www.abc.net.au/news/2024-01-25/the-long-game-how-tennis-got-longer/103384016">BBC News</a>, suggest that rallies aren’t getting much longer overall, a closer look reveals a shift in rally patterns.</p>
<div id="7c7de691" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> advanced_match_stats.copy()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"date"</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">"match_id"</span>].<span class="bu">str</span>[:<span class="dv">8</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter </span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[(df[<span class="st">"date"</span>].dt.year <span class="op">&gt;=</span> <span class="dv">1985</span>) <span class="op">&amp;</span> (df[<span class="st">"date"</span>].dt.year <span class="op">&lt;=</span> <span class="dv">2022</span>)]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>grand_slam_keywords <span class="op">=</span> [<span class="st">"Australian_Open"</span>, <span class="st">"French_Open"</span>, <span class="st">"Roland_Garros"</span>, <span class="st">"Wimbledon"</span>, <span class="st">"US_Open"</span>]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[df[<span class="st">"match_id"</span>].<span class="bu">str</span>.contains(<span class="st">"|"</span>.join(grand_slam_keywords))]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Categorize Touches into bins</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="bu">float</span>(<span class="st">"inf"</span>)]  <span class="co"># 0-3, 4+</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">"1-3"</span>, <span class="st">"4+"</span>]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"Touches_Category"</span>] <span class="op">=</span> pd.cut(df[<span class="st">"Touches"</span>], bins<span class="op">=</span>bins, labels<span class="op">=</span>labels, right<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute sum of touches per match per category</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>rally_sum_per_match <span class="op">=</span> df.groupby([<span class="st">"match_id"</span>, <span class="st">"date"</span>, <span class="st">"Touches_Category"</span>])[<span class="st">"Touches"</span>].count().reset_index()</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove matches where all categories have Touches = 0 -&gt; Excluding Aces</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>total_touches_per_match <span class="op">=</span> rally_sum_per_match.groupby([<span class="st">"match_id"</span>, <span class="st">"date"</span>])[<span class="st">"Touches"</span>].<span class="bu">sum</span>()</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>valid_matches <span class="op">=</span> total_touches_per_match[total_touches_per_match <span class="op">&gt;</span> <span class="dv">0</span>].index</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>rally_sum_per_match <span class="op">=</span> rally_sum_per_match.set_index([<span class="st">"match_id"</span>, <span class="st">"date"</span>]).loc[valid_matches].reset_index()</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the average rally count per year for each category</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>rally_sum_per_match[<span class="st">"year"</span>] <span class="op">=</span> rally_sum_per_match[<span class="st">"date"</span>].dt.year</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>total_touches_per_year <span class="op">=</span> rally_sum_per_match.groupby(<span class="st">"year"</span>)[<span class="st">"Touches"</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>total_touches_per_year.rename(columns<span class="op">=</span>{<span class="st">"Touches"</span>: <span class="st">"Total_Touches"</span>}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>avg_rally_per_year <span class="op">=</span> rally_sum_per_match.groupby([<span class="st">"year"</span>, <span class="st">"Touches_Category"</span>])[<span class="st">"Touches"</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge with total touches per year</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>avg_rally_per_year <span class="op">=</span> avg_rally_per_year.merge(total_touches_per_year, on<span class="op">=</span><span class="st">"year"</span>)</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute proportion</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>avg_rally_per_year[<span class="st">"Proportion"</span>] <span class="op">=</span> avg_rally_per_year[<span class="st">"Touches"</span>] <span class="op">/</span> avg_rally_per_year[<span class="st">"Total_Touches"</span>]</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot scatter plot with regression line</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>category_colors <span class="op">=</span> {<span class="st">"1-3"</span>: <span class="st">"red"</span>, <span class="st">"4+"</span>: <span class="st">"purple"</span>}</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> category, color <span class="kw">in</span> category_colors.items():</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>    subset <span class="op">=</span> avg_rally_per_year[avg_rally_per_year[<span class="st">"Touches_Category"</span>] <span class="op">==</span> category]</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    sns.regplot(x<span class="op">=</span>subset[<span class="st">"year"</span>], y<span class="op">=</span>subset[<span class="st">"Proportion"</span>], scatter<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="ss">f"Touches </span><span class="sc">{</span>category<span class="sc">}</span><span class="ss">"</span>, color<span class="op">=</span>color, order<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Year"</span>)</span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Proportion of Touches"</span>)</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Proportion of Rally Count in Grand Slam (1985-2022) - Scatter &amp; Regression"</span>)</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Move legend outside the plot</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper left"</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Show plot</span></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-13-output-1.png" width="656" height="464" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The proportion of rallies lasting beyond four shots has steadily increased since 1985, while those with fewer than three shots have decreased. This suggests a move away from the traditional serve-and-volley game toward a style that relies more on baseline play, where players chase down balls and engage in longer exchanges. This shift can likely be attributed to advancements in tennis racquet technology, improvements in player fitness, and the increasing emphasis on rallying from the baseline.</p>
<p>Additionally, there has been a rise in the number of aces per match, signaling the growing importance of powerful serves in today’s game.</p>
<div id="da4ee190" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> atp_match_stats.copy()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data.</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">"tourney_date"</span>] <span class="op">=</span> pd.to_datetime(final_df[<span class="st">"tourney_date"</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">"year"</span>] <span class="op">=</span> final_df[<span class="st">"tourney_date"</span>].dt.year</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter for relevant years (adjust range as needed)</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> final_df[(final_df[<span class="st">"year"</span>] <span class="op">&gt;=</span> <span class="dv">1995</span>) <span class="op">&amp;</span> (final_df[<span class="st">"year"</span>] <span class="op">&lt;=</span> <span class="dv">2022</span>)]</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute average aces per match per year</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>avg_aces_per_year <span class="op">=</span> final_df.groupby(<span class="st">"year"</span>)[<span class="st">"w_ace"</span>].mean().reset_index()</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>sns.regplot(x<span class="op">=</span>avg_aces_per_year[<span class="st">"year"</span>], y<span class="op">=</span>avg_aces_per_year[<span class="st">"w_ace"</span>], </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>            order<span class="op">=</span><span class="dv">2</span>, scatter<span class="op">=</span><span class="va">True</span>, line_kws<span class="op">=</span>{<span class="st">"color"</span>: <span class="st">"red"</span>}, scatter_kws<span class="op">=</span>{<span class="st">"color"</span>: <span class="st">"blue"</span>})</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Year"</span>)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Average Aces per Match"</span>)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Average Number of Aces per Match Over the Years"</span>)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-14-output-1.png" width="593" height="474" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="average-match-times-over-the-years" class="level4">
<h4 class="anchored" data-anchor-id="average-match-times-over-the-years">Average Match Times over the years</h4>
<p>Across the tennis world, match durations have steadily trended upwards over the years, reflecting the evolving nature of the sport. This trend is consistent across most major tournaments, where matches are lasting longer on average - roughly 20% longer since 1997! Several factors contribute to this change, with some being the aforementioned advancements in racquet technology, improved player fitness, and a shift in playing styles, but interestingly, serve preparation (the time a player spends bouncing the ball or otherwise getting ready to serve) has also been getting longer..</p>
<p>In analyzing the trend of match durations, a smoothing technique called spline interpolation was employed. This method is used to fit a smooth curve to the data, helping to identify underlying patterns and trends over time. The make_interp_spline method creates a spline (a type of piecewise polynomial) that ensures a smooth, continuous curve through the data points, providing a clearer representation of the overall trend while minimizing the noise from individual data points.</p>
<p>However, it is important to note that the dataset used to track these trends has some gaps. Specifically, data from the 1997 Australian Open is incomplete, and no data is available for the 1998 and 2015 US Open tournaments. Additionally, the 2020 Wimbledon was not held due to the global pandemic, and the 2024 Australian Open data is also incomplete, so it has been excluded from the analysis.</p>
<div id="51874a50" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> make_interp_spline</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mplcursors</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Load dataset</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> atp_match_stats.copy()</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert tourney_date to datetime format and extract year</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">"tourney_date"</span>] <span class="op">=</span> pd.to_datetime(final_df[<span class="st">"tourney_date"</span>], <span class="bu">format</span><span class="op">=</span><span class="st">"%Y%m</span><span class="sc">%d</span><span class="st">"</span>)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">"year"</span>] <span class="op">=</span> final_df[<span class="st">"tourney_date"</span>].dt.year</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter data (excluding 2024 Australian Open due to incomplete data)</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> final_df[(final_df[<span class="st">"year"</span>] <span class="op">&gt;=</span> <span class="dv">1997</span>) <span class="op">&amp;</span> (final_df[<span class="st">"year"</span>] <span class="op">&lt;=</span> <span class="dv">2023</span>)]</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove known missing data cases</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>excluded_entries <span class="op">=</span> [</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1997</span>, <span class="st">"Australian Open"</span>),  </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1998</span>, <span class="st">"US Open"</span>),          </span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2015</span>, <span class="st">"US Open"</span>),          </span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2020</span>, <span class="st">"Wimbledon"</span>)         </span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year, tourney <span class="kw">in</span> excluded_entries:</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    final_df <span class="op">=</span> final_df[<span class="op">~</span>((final_df[<span class="st">"year"</span>] <span class="op">==</span> year) <span class="op">&amp;</span> (final_df[<span class="st">"tourney_name"</span>].<span class="bu">str</span>.contains(tourney, case<span class="op">=</span><span class="va">False</span>)))]</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter for Grand Slam matches</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>grand_slam_matches <span class="op">=</span> final_df[final_df[<span class="st">"tourney_level"</span>] <span class="op">==</span> <span class="st">"G"</span>]</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute average match duration per year for each Grand Slam</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>avg_minutes_per_tourney <span class="op">=</span> grand_slam_matches.groupby([<span class="st">"year"</span>, <span class="st">"tourney_name"</span>])[<span class="st">"minutes"</span>].mean().reset_index()</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Define colors and line styles for each Grand Slam</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>tourney_styles <span class="op">=</span> {</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Australian Open"</span>: {<span class="st">"color"</span>: <span class="st">"blue"</span>, <span class="st">"linestyle"</span>: <span class="st">"solid"</span>},  </span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Roland Garros"</span>: {<span class="st">"color"</span>: <span class="st">"red"</span>, <span class="st">"linestyle"</span>: <span class="st">"dotted"</span>},    </span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Wimbledon"</span>: {<span class="st">"color"</span>: <span class="st">"green"</span>, <span class="st">"linestyle"</span>: <span class="st">"dashed"</span>},      </span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="st">"US Open"</span>: {<span class="st">"color"</span>: <span class="st">"purple"</span>, <span class="st">"linestyle"</span>: <span class="st">"dashdot"</span>}       </span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Settings</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>), facecolor<span class="op">=</span><span class="st">"white"</span>)</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>ax.set_facecolor(<span class="st">"white"</span>) </span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Store points for hover functionality</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>hover_points <span class="op">=</span> []</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tourney, style <span class="kw">in</span> tourney_styles.items():</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    subset <span class="op">=</span> avg_minutes_per_tourney[avg_minutes_per_tourney[<span class="st">"tourney_name"</span>].<span class="bu">str</span>.contains(tourney, case<span class="op">=</span><span class="va">False</span>)]</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> subset[<span class="st">"year"</span>].values</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> subset[<span class="st">"minutes"</span>].values</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">&gt;</span> <span class="dv">3</span>:  </span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>        x_smooth <span class="op">=</span> np.linspace(x.<span class="bu">min</span>(), x.<span class="bu">max</span>(), <span class="dv">300</span>)  </span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>        spline <span class="op">=</span> make_interp_spline(x, y, k<span class="op">=</span><span class="dv">3</span>)  </span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        y_smooth <span class="op">=</span> spline(x_smooth)</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>        x_smooth, y_smooth <span class="op">=</span> x, y  </span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot smoothed lines with different styles</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>    ax.plot(x_smooth, y_smooth, linestyle<span class="op">=</span>style[<span class="st">"linestyle"</span>], color<span class="op">=</span>style[<span class="st">"color"</span>], linewidth<span class="op">=</span><span class="fl">2.5</span>, label<span class="op">=</span>tourney)</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store original data points for hover tooltips (hidden dots)</span></span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>    scatter <span class="op">=</span> ax.scatter(x, y, color<span class="op">=</span>style[<span class="st">"color"</span>], s<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="dv">0</span>)  </span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>    hover_points.append(scatter)</span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Year"</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Average Match Duration (minutes)"</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>, labelpad<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Grand Slam Match Durations (1997-2023)"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">"bold"</span>, pad<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Grids</span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a>ax.yaxis.grid(<span class="va">True</span>, linestyle<span class="op">=</span><span class="st">"--"</span>, linewidth<span class="op">=</span><span class="fl">0.6</span>, color<span class="op">=</span><span class="st">"#E0E0E0"</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)  </span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a>ax.xaxis.grid(<span class="va">False</span>)  </span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"top"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a>ax.spines[<span class="st">"right"</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">"Grand Slam"</span>, fontsize<span class="op">=</span><span class="dv">10</span>, title_fontsize<span class="op">=</span><span class="dv">11</span>, loc<span class="op">=</span><span class="st">"upper left"</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a>cursor <span class="op">=</span> mplcursors.cursor(hover_points, hover<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a>cursor.<span class="ex">connect</span>(<span class="st">"add"</span>, <span class="kw">lambda</span> sel: sel.annotation.set_text(<span class="ss">f"</span><span class="sc">{</span><span class="bu">int</span>(sel.target[<span class="dv">0</span>])<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>sel<span class="sc">.</span>target[<span class="dv">1</span>]<span class="sc">:.1f}</span><span class="ss"> min"</span>))</span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a><span class="co"># Show plot</span></span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-15-output-1.png" width="752" height="560" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="what-makes-a-tennis-star" class="level3">
<h3 class="anchored" data-anchor-id="what-makes-a-tennis-star">What makes a Tennis Star?</h3>
<p>When we consider what makes a tennis star, the immediate answer often revolves around their ability to dominate major titles, such as Grand Slams—just as Roger Federer, Rafael Nadal, and Novak Djokovic have done. This dominance is often associated with consistently winning matches, accumulating titles, and generating large numbers of total points won across their careers.</p>
<p>However, a deeper look at the statistics reveals an interesting paradox. The variation in the percentage of points won between players is minimal, even for the game’s elite. For instance, a player like Federer, often regarded as one of the sport’s greatest, only wins slightly more than half of the points played in a match.</p>
<div id="b268b6a5" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info <span class="op">=</span> pd.read_csv(<span class="st">"data/atp_100_advanced_player_info.csv"</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'TPW%' to numeric by stripping '%' and converting to float</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info[<span class="st">'TPW%'</span>] <span class="op">=</span> atp_100_advanced_player_info[<span class="st">'TPW%'</span>].<span class="bu">str</span>.rstrip(<span class="st">'%'</span>).astype(<span class="bu">float</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info[<span class="st">'M W%'</span>] <span class="op">=</span> atp_100_advanced_player_info[<span class="st">'M W%'</span>].<span class="bu">str</span>.rstrip(<span class="st">'%'</span>).astype(<span class="bu">float</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate 2.5th and 97.5th percentiles</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>tpw_2_5th_percentile <span class="op">=</span> atp_100_advanced_player_info[<span class="st">'TPW%'</span>].quantile(<span class="fl">0.025</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>tpw_97_5th_percentile <span class="op">=</span> atp_100_advanced_player_info[<span class="st">'TPW%'</span>].quantile(<span class="fl">0.975</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot histogram with percentiles</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info[<span class="st">'TPW%'</span>].plot(kind<span class="op">=</span><span class="st">'hist'</span>, bins<span class="op">=</span><span class="dv">12</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Add vertical lines for the percentiles</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>plt.axvline(tpw_2_5th_percentile, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'dashed'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>plt.axvline(tpw_97_5th_percentile, color<span class="op">=</span><span class="st">'g'</span>, linestyle<span class="op">=</span><span class="st">'dashed'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">40</span>, <span class="dv">60</span>)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'TPW%'</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Distribution of Points Won%'</span>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Grid for readability</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">'y'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-16-output-1.png" width="678" height="455" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>In fact, among the top 100 current players, 95% of them average between 47.44% and 54.02% of total points won per match. Given such a narrow range in points won—just slightly above 50%—one might wonder: How is it possible for players like the Big Three to consistently dominate the sport? The small variation in points won suggests that, almost by chance, even players ranked outside the top 100 could theoretically reach the No.&nbsp;1 spot!</p>
<div id="e9cca538" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot scatter plot</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(atp_100_advanced_player_info[<span class="st">'TPW%'</span>], atp_100_advanced_player_info[<span class="st">'M W%'</span>])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'TPW%'</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'M W%'</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Scatter Plot of TPW% vs M W%'</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Show plot</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-17-output-1.png" width="596" height="455" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>However, upon closer examination, it becomes clear that despite the narrow difference in points won, a higher percentage of points won plays a crucial role in a player’s ability to consistently win sets and ultimately secure victories in matches.</p>
<p>To understand why this is the case, we can look at a few possible explanations:</p>
<ul>
<li><p>Not all points in tennis carry the same weight. Some points are more critical than others, and top players excel at capitalizing on these pivotal moments.</p></li>
<li><p>Specific skills in tennis are essential for consistently winning points.</p></li>
</ul>
<p>A straightforward way to test this hypothesis is by using a correlation matrix, which allows us to explore the relationships between important variables and understand how various stats may influence each other.</p>
<section id="investigation" class="level4">
<h4 class="anchored" data-anchor-id="investigation">Investigation</h4>
<p>For the purposes of this report, we examine the effects of the following variables on an individual players average Match Win Rate:</p>
<ul>
<li><p>BPConv%: Break Point (define) Opportunities converted.</p></li>
<li><p>BPSvd%: Percentage of Break Points saved on Serve.</p></li>
<li><p>RPW: Percentage of Return Points won,</p></li>
<li><p>Brk%: Break Rate, which is the percentage of return games won.</p></li>
<li><p>Ace%: Ace Rate, which are serves that the opponent does not manage to make touch.</p></li>
<li><p>Hld%: Hold Rate, which is the percentage of service games won.</p></li>
<li><p>1stIn: Percentage of First Serves In.</p></li>
<li><p>TB W%: Tiebreak winning percentage.</p></li>
</ul>
<div id="2bc9496c" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">'M W%'</span>, <span class="st">'BPConv%'</span>, <span class="st">'BPSvd%'</span>, <span class="st">'RPW'</span>, <span class="st">'Brk%'</span>, <span class="st">'Ace%'</span>, <span class="st">'Hld%'</span>, <span class="st">'1stIn'</span>]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the variables to numeric</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info <span class="op">=</span> pd.read_csv(<span class="st">"data/atp_100_advanced_player_info.csv"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">'M W%'</span>, <span class="st">'BPConv%'</span>, <span class="st">'BPSvd%'</span>, <span class="st">'RPW'</span>, <span class="st">'Brk%'</span>, <span class="st">'Ace%'</span>, <span class="st">'Hld%'</span>, <span class="st">'1stIn'</span>, <span class="st">'TB W%'</span>]</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> variables:</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    atp_100_advanced_player_info[var] <span class="op">=</span> atp_100_advanced_player_info[var].<span class="bu">str</span>.rstrip(<span class="st">'%'</span>).astype(<span class="bu">float</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the correlation matrix</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>correlation_matrix <span class="op">=</span> atp_100_advanced_player_info[variables].corr()</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the correlation matrix using seaborn heatmap</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>sns.heatmap(correlation_matrix, annot<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'coolwarm'</span>, fmt<span class="op">=</span><span class="st">'.2f'</span>, linewidths<span class="op">=</span><span class="fl">0.5</span>, cbar<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Set title</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Correlation Matrix of Tennis Statistics'</span>)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-18-output-1.png" width="799" height="583" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Observations from the correlation matrix reveal that Hold Rate, Tiebreak Winning Percentage, and Break Rate exhibit some of the highest correlations with Match Win Rate, with values of 0.61, 0.54, and 0.47, respectively. These metrics are crucial as they represent key moments within a match: winning your own service game (Hold Rate), prevailing in tiebreaks (Tiebreak Win Percentage), and converting or defending break points (Break Rate). Each of these areas has a direct impact on a player’s ability to maintain momentum and secure victories</p>
<p>An interesting pattern emerges when examining the correlation between Break Rate and Percentage of Return Points Won. The high correlation between these two variables suggests that a player’s ability to break serve is closely tied to their effectiveness on return points. That is, players who win a higher proportion of return points are more likely to break their opponent’s serve, which ultimately contributes to a higher overall break rate.</p>
<p>However, this high level of correlation also suggests multicollinearity, which makes it difficult to separate out their individual effects on the Match Win Rate. This could inflate standard errors for the regression coefficients, making it harder to assess the true effect of each variable on the outcome. Whilst we may not be building a predictive model for our analysis, it is noteworthy enough to consider either removing one of the variables, or apply other techniques such as Principal Component Analysis to merge the two variables going forward.</p>
</section>
<section id="past-and-present---player-performance" class="level4">
<h4 class="anchored" data-anchor-id="past-and-present---player-performance">Past and Present - Player Performance</h4>
<p>When comparing player performance across generations, one key area of focus is how new-generation players are measuring up to the Big 3, particularly in metrics like Percentage of Return Points Won. In a 2020 study by Tim Roback &amp; Nick Anderson from <a href="https://rpubs.com/tdroback/Tennis_Project">Tennis Project</a>, it was found that Percentage of Return Points Won showed a strong positive correlation with individual player match win rates.</p>
<div class="img-float">
<p><img src="images/tennis_project_rpw.png" class="img-fluid" style="float: left; margin: 5px"></p>
</div>
<p>What stands out is the impressive consistency with which players like Federer, Nadal, and Djokovic have maintained some of the highest Return Points Won percentages, typically ranging from 40% to 42%, a significant benchmark in the sport.</p>
<p>With Federer and Nadal now retired, Djokovic continues to perform at a high level, maintaining a return win rate close to 41%. However, new rising stars like Carlos Alcaraz and Jannik Sinner are swiftly emerging as the successors to these legends. Both players are demonstrating similar performances and achieving victories comparable to what Nadal and Federer once did, making it increasingly challenging for Djokovic to maintain the #1 spot. In this evolving dynamic, the torch appears to be passing to a new era of tennis champions.</p>
<div id="dad0b0d7" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Return Point winning percentage</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> linregress</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the scatter plot for RPW vs M W%</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>plt.scatter(atp_100_advanced_player_info[<span class="st">'RPW'</span>], atp_100_advanced_player_info[<span class="st">'M W%'</span>], alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Add regression line</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>slope, intercept, r_value, p_value, std_err <span class="op">=</span> linregress(atp_100_advanced_player_info[<span class="st">'RPW'</span>], atp_100_advanced_player_info[<span class="st">'M W%'</span>])</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the regression line values</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>regression_line <span class="op">=</span> slope <span class="op">*</span> atp_100_advanced_player_info[<span class="st">'RPW'</span>] <span class="op">+</span> intercept</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the regression line</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>plt.plot(atp_100_advanced_player_info[<span class="st">'RPW'</span>], regression_line, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the index of the players (without country code)</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>players <span class="op">=</span> [<span class="st">'Jannik Sinner'</span>, <span class="st">'Novak Djokovic'</span>, <span class="st">'Carlos Alcaraz'</span>]</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> player <span class="kw">in</span> players:</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove any additional country code information</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    player_data <span class="op">=</span> atp_100_advanced_player_info[atp_100_advanced_player_info[<span class="st">'Player'</span>].<span class="bu">str</span>.contains(player, case<span class="op">=</span><span class="va">False</span>, na<span class="op">=</span><span class="va">False</span>)]</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if player data is found</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> player_data.empty:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        plt.text(player_data[<span class="st">'RPW'</span>].values[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">0.3</span>, player_data[<span class="st">'M W%'</span>].values[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">0.5</span>, player,</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>                 fontsize<span class="op">=</span><span class="dv">9</span>, ha<span class="op">=</span><span class="st">'right'</span>, color<span class="op">=</span><span class="st">'black'</span>,</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>                 bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, boxstyle<span class="op">=</span><span class="st">'round,pad=0.3'</span>))</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Player </span><span class="sc">{</span>player<span class="sc">}</span><span class="ss"> not found in the DataFrame."</span>)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Labels and title</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'RPW'</span>)</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'M W%'</span>)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Scatter Plot of RPW vs M W%'</span>)</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Show plot</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-19-output-1.png" width="663" height="455" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="rising-star" class="level3">
<h3 class="anchored" data-anchor-id="rising-star">Rising Star</h3>
<p>While we can continue to analyze the previously defined metrics individually (as we did with RPW) to assess which players perform the best, the high dimensionality of the data makes it challenging to view everything at once in a single visualization. Additionally, as mentioned earlier, some of the variables used in constructing the model exhibit signs of multicollinearity.</p>
<p>To better understand which groups of attributes align players with similar performance characteristics, we must address the complexity of the data. Although each variable provides valuable insight, traditional regression methods only allow us to examine the relationship between two variables at a time, making it difficult to identify clusters of players.</p>
<p>To overcome this limitation, I apply Principal Component Analysis (PCA) for dimensionality reduction. PCA enables us to condense the high-dimensional data into a more manageable form, allowing us to visually identify any clusters of strong-performing players. This approach will help us uncover hidden patterns that might otherwise be obscured.</p>
<div id="fcd5ff68" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load Data</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>atp_100_advanced_player_info <span class="op">=</span> pd.read_csv(<span class="st">"data/atp_100_advanced_player_info.csv"</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the relevant variables and convert percentage columns to float</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>variables <span class="op">=</span> [<span class="st">'BPConv%'</span>, <span class="st">'BPSvd%'</span>, <span class="st">'RPW'</span>, <span class="st">'Brk%'</span>, <span class="st">'Ace%'</span>, <span class="st">'Hld%'</span>, <span class="st">'1stIn'</span>, <span class="st">'TB W%'</span>]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> variables:</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    atp_100_advanced_player_info[var] <span class="op">=</span> atp_100_advanced_player_info[var].<span class="bu">str</span>.rstrip(<span class="st">'%'</span>).astype(<span class="bu">float</span>)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Select only the variables needed for PCA</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> atp_100_advanced_player_info[variables]</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Standardize the data</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>X_scaled <span class="op">=</span> scaler.fit_transform(X)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform PCA</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>X_pca <span class="op">=</span> pca.fit_transform(X_scaled)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a DataFrame for the first two principal components</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>pca_df <span class="op">=</span> pd.DataFrame(X_pca, columns<span class="op">=</span>[<span class="st">'PC1'</span>, <span class="st">'PC2'</span>])</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Add the player names to the PCA DataFrame</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>pca_df[<span class="st">'Player'</span>] <span class="op">=</span> atp_100_advanced_player_info[<span class="st">'Player'</span>]</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co">######## Get the PC Loadings Visualisation</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the loadings (components) for the first two PCs</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>loadings <span class="op">=</span> pca.components_</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a DataFrame for the loadings of PC1 and PC2</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>loadings_df <span class="op">=</span> pd.DataFrame(loadings.T, columns<span class="op">=</span>[<span class="st">'PC1'</span>, <span class="st">'PC2'</span>], index<span class="op">=</span>variables)</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the loadings for PC1 and PC2</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>plt.barh(loadings_df.index, loadings_df[<span class="st">'PC1'</span>], color<span class="op">=</span><span class="st">'b'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'PC1'</span>)</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>plt.barh(loadings_df.index, loadings_df[<span class="st">'PC2'</span>], color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, label<span class="op">=</span><span class="st">'PC2'</span>)</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Add labels and title</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Loading Value'</span>)</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Loadings of the First Two Principal Components (PC1 and PC2)'</span>)</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>,linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the legend</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-20-output-1.png" width="620" height="455" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>After applying Principal Component Analysis (PCA) to reduce the dimensionality of the data, we can examine the loadings of the first two PCs (principal components) to understand which variables contribute the most to the variance captured by these components. These loadings indicate the strength and direction of each variable’s relationship with the principal components, essentially revealing how the original features were combined.</p>
<p>Principal Component 1:</p>
<ul>
<li><p>In this case, Hold Rate (Hld%), Ace Rate (Ace%), and Break Points Saved (BPSvd%) have the highest positive loadings on PC1, suggesting that this principal component strongly represents players who excel in serving and holding their service games.</p></li>
<li><p>Conversely, Break Rate (Brk%), Break Point Conversion (BPConv%) and Return Points Won (RPW) have the highest negative loadings, indicating that PC1 also captures players who thrive on breaking opponents’ serves—but in the opposite direction of strong servers. Players with high PC1 scores are likely dominant servers, while those with low PC1 scores are more effective returners.</p></li>
</ul>
<p>Principal Component 2:</p>
<ul>
<li><p>Unlike PC1, Tiebreak Win Percentage (TB W%), Hold Rate (Hld%), and Break Points Saved (BPSvd%) have the highest negative loadings, suggesting that players who excel in these areas are positioned on one end of this component.</p></li>
<li><p>Notably, there are no significant positive loadings, meaning PC2 does not strongly represent any particular attributes in the opposite direction.</p></li>
</ul>
<p>Next, I examine the loadings of both principal components in a Biplot, to gain insight into the patterns that differentiate top-performing players from others.</p>
<div id="5f2f9cab" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> biplot(pca, X_pca, labels, variables):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="dv">7</span>))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    pc1, pc2 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span>  <span class="co"># First two principal components</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scatter plot of the projected data</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    plt.scatter(X_pca[:, pc1], X_pca[:, pc2], alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add the variable loadings (vectors)</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, var <span class="kw">in</span> <span class="bu">enumerate</span>(variables):</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        plt.arrow(<span class="dv">0</span>, <span class="dv">0</span>, pca.components_[pc1, i] <span class="op">*</span> <span class="dv">3</span>, pca.components_[pc2, i] <span class="op">*</span> <span class="dv">3</span>, </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>                  color<span class="op">=</span><span class="st">'r'</span>, alpha<span class="op">=</span><span class="fl">0.75</span>, head_width<span class="op">=</span><span class="fl">0.1</span>, length_includes_head<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        plt.text(pca.components_[pc1, i] <span class="op">*</span> <span class="fl">3.5</span>, pca.components_[pc2, i] <span class="op">*</span> <span class="fl">3.5</span>, </span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>                 var, color<span class="op">=</span><span class="st">'r'</span>, fontsize<span class="op">=</span><span class="dv">10</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight the players of interest</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    players <span class="op">=</span> [<span class="st">'Sinner'</span>, <span class="st">'Djokovic'</span>, <span class="st">'Alcaraz'</span>, <span class="st">'Raphael Collignon'</span>, <span class="st">'Medvedev'</span>, <span class="st">'Zverev'</span>, <span class="st">'Berrettini'</span>, <span class="st">'de Minaur'</span>, <span class="st">'Fritz'</span>]</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> player <span class="kw">in</span> players:</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        player_data <span class="op">=</span> atp_100_advanced_player_info[atp_100_advanced_player_info[<span class="st">'Player'</span>].<span class="bu">str</span>.contains(player, case<span class="op">=</span><span class="va">False</span>, na<span class="op">=</span><span class="va">False</span>)]</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> player_data.empty:</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> player_data.index[<span class="dv">0</span>]</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            plt.scatter(X_pca[idx, pc1], X_pca[idx, pc2], color<span class="op">=</span><span class="st">'black'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            plt.text(X_pca[idx, pc1] <span class="op">-</span> <span class="fl">0.5</span>, X_pca[idx, pc2] <span class="op">-</span> <span class="fl">0.5</span>, player, fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="ss">f"PC</span><span class="sc">{</span>pc1<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>pca<span class="sc">.</span>explained_variance_ratio_[pc1]<span class="op">*</span><span class="dv">100</span><span class="sc">:.2f}</span><span class="ss">%)"</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="ss">f"PC</span><span class="sc">{</span>pc2<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>pca<span class="sc">.</span>explained_variance_ratio_[pc2]<span class="op">*</span><span class="dv">100</span><span class="sc">:.2f}</span><span class="ss">%)"</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"PCA Biplot (First Two PCs)"</span>, fontsize<span class="op">=</span><span class="dv">14</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the improved biplot function</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>biplot(pca, X_pca, atp_100_advanced_player_info[<span class="st">'Player'</span>], variables)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-21-output-1.png" width="764" height="605" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Upon examining the biplot for the current Top 100 ATP players and highlighting some of the strongest and most well-known competitors—such as Djokovic, Sinner, Alcaraz, and Zverev—we observe three distinct clusters based on the selected performance metrics:</p>
<ul>
<li><p><strong>Serve-Dominant Players</strong> – These players excel in Hold Rate (Hld%), Ace Rate (Ace%), and Break Points Saved (BPSvd%), indicating a strong ability to maintain their service games, featuring players such as Berretini or Fritz.</p></li>
<li><p><strong>Return-Oriented Players</strong> – This group is characterized by high Break Rate (Brk%), Break Point Conversion (BPConv%), and Return Points Won (RPW), showcasing their effectiveness in breaking opponents’ serves, such as de Minaur, Medvedev, or Alcaraz (who is well regarded for his ability to chase down balls).</p></li>
</ul>
<p><strong>All-Court Players</strong> – These players exhibit a large negative loading in PC2, which we previously identified as associated with Tiebreak Win Percentage (TB W%), Hold Rate (Hld%), and Break Points Saved (BPSvd%). Notably, they perform at a high level across multiple aspects of the game, demonstrating well-rounded dominance, like with Djokovic, Zverev, or far in far leading as the current Rank 1 Player, Jannik Sinner.</p>
<p>Just for reference, I have highlighted a player, such as Raphael Collignon, who is Rank 92 as at W1 of March 2025.</p>
<div id="0fd06013" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the explained variance ratio for all principal components</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform PCA on the standardized data (as done earlier)</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>X_pca_all <span class="op">=</span> pca.fit_transform(X_scaled)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the explained variance ratio for all principal components</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>explained_variance_ratio <span class="op">=</span> pca.explained_variance_ratio_</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the explained variance for all PCs (Elbow Method)</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.figure(figsize=(10, 6))</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the explained variance for each principal component</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(explained_variance_ratio) <span class="op">+</span> <span class="dv">1</span>), explained_variance_ratio, marker<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">'b'</span>, label<span class="op">=</span><span class="st">'Explained Variance'</span>)</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Principal Component'</span>)</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Explained Variance Ratio'</span>)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Explained Variance by Each Principal Component (Elbow Method)'</span>)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a vertical line to indicate where the "elbow" occurs</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span><span class="dv">4</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">"Elbow (Optimal Number of Components)"</span>)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a><span class="co"># for i, ratio in enumerate(explained_variance_ratio, 1):</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(f"PC{i}: {ratio:.4f} ({ratio*100:.2f}%)")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tennis_star_refined_files/figure-html/cell-22-output-1.png" width="593" height="455" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As a side note, whilst I have visualized only the first two principal components to provide a clear graphical representation, it is important to note that PCA inherently reduces dimensionality, meaning some information from the original data is lost in the process. By projecting complex, high-dimensional data onto a simpler plane, we prioritize interpretability at the expense of completeness.</p>
<p>In this case, the first two principal components explain approximately 67.67% of the total variance. However, analyzing the elbow of the curve suggests that the optimal number of components would be four, which would capture around 90% of the total variance, providing a more comprehensive representation of player performance.</p>
</section>
</section>
<section id="concluding-remarks" class="level2">
<h2 class="anchored" data-anchor-id="concluding-remarks">Concluding Remarks</h2>
<p>From the early 2000s, men’s tennis was dominated by three legendary players—Federer, Nadal, and Djokovic. However, as the sport evolves, demanding greater physicality from longer rallies, and extended match durations, a new generation of players is slowly beginning to take their place, where Rising stars like Alcaraz and Sinner are showcasing a level of dominance reminiscent of the Big Three in their prime, making it clear why they are regarded as the future of tennis - with Sinner dominating the game by far at the moment.</p>
<p>Of course, in tennis, there are no guaranteed victors. The sport is constantly evolving, and new contenders continue to emerge. For example, Alex de Minaur, a promising Australian star, recently became the first to reach an Australian Open quarterfinal since Nick Kyrgios. Meanwhile, young talents like Learner Tien have shown remarkable consistency, defeating top-ranked ATP players such as Medvedev or Zverev despite being outside the top 100.</p>
<p>But as the game continues to evolve, one thing remains certain: the relentless pursuit of excellence will always define the greatest champions.</p>
<div class="img-float">
<p><img src="images/djokovic.jpg" class="img-fluid" style="float: left; margin: 5px; width: 80%"></p>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>